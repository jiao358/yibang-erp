<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Excel 缓存任务调试工具</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #303133;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #409eff;
        }
        .button {
            background: #409eff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 4px;
            font-size: 14px;
        }
        .button:hover {
            background: #66b1ff;
        }
        .button.danger {
            background: #f56c6c;
        }
        .button.danger:hover {
            background: #f78989;
        }
        .button.success {
            background: #67c23a;
        }
        .button.success:hover {
            background: #85ce61;
        }
        .info-box {
            background: #f4f4f5;
            border: 1px solid #dcdfe6;
            border-radius: 4px;
            padding: 12px;
            margin: 8px 0;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        .status.processing {
            background: #e1f3d8;
            color: #67c23a;
        }
        .status.completed {
            background: #e1f3d8;
            color: #67c23a;
        }
        .status.failed {
            background: #fde2e2;
            color: #f56c6c;
        }
        .status.system-processing {
            background: #e6f7ff;
            color: #1890ff;
        }
        .status.pending {
            background: #fff7e6;
            color: #fa8c16;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔧 AI Excel 缓存任务调试工具</h1>
        <p>用于调试和修复AI Excel导入模块的虚拟任务缓存问题</p>
    </div>

    <div class="container">
        <div class="section-title">📋 当前缓存任务状态</div>
        <button class="button" onclick="loadCacheStatus()">刷新状态</button>
        <button class="button success" onclick="clearExpiredTasks()">清理过期任务</button>
        <button class="button danger" onclick="clearAllTasks()">清理所有缓存任务</button>
        <div id="cacheStatus" class="info-box">点击"刷新状态"查看当前缓存任务</div>
    </div>

    <div class="container">
        <div class="section-title">🔍 任务状态分析</div>
        <button class="button" onclick="analyzeTasks()">分析任务状态</button>
        <button class="button" onclick="checkProcessingTasks()">检查处理中任务</button>
        <div id="taskAnalysis" class="info-box">点击"分析任务状态"查看详细分析</div>
    </div>

    <div class="container">
        <div class="section-title">🛠️ 修复操作</div>
        <button class="button success" onclick="fixCacheIssues()">自动修复缓存问题</button>
        <button class="button" onclick="simulateTaskCompletion()">模拟任务完成</button>
        <button class="button" onclick="testUploadBlock()">测试上传阻止</button>
        <div id="fixResults" class="info-box">点击相应按钮执行修复操作</div>
    </div>

    <div class="container">
        <div class="section-title">📊 调试信息</div>
        <button class="button" onclick="showDebugInfo()">显示调试信息</button>
        <button class="button" onclick="exportDebugData()">导出调试数据</button>
        <div id="debugInfo" class="info-box">点击"显示调试信息"查看详细调试数据</div>
    </div>

    <script>
        const CACHED_TASKS_KEY = 'aiExcelCachedTasks';
        
        // 加载缓存状态
        function loadCacheStatus() {
            try {
                const cachedTasks = loadCachedTasks();
                const statusDiv = document.getElementById('cacheStatus');
                
                if (cachedTasks.length === 0) {
                    statusDiv.textContent = '✅ 没有缓存任务';
                    return;
                }
                
                let status = `📋 找到 ${cachedTasks.length} 个缓存任务:\n\n`;
                
                cachedTasks.forEach((task, index) => {
                    const statusClass = getStatusClass(task.status);
                    status += `${index + 1}. 任务ID: ${task.taskId}\n`;
                    status += `   文件名: ${task.fileName}\n`;
                    status += `   状态: <span class="status ${statusClass}">${task.status}</span>\n`;
                    status += `   创建时间: ${task.createdAt}\n`;
                    status += `   是否缓存: ${task.isCached ? '是' : '否'}\n`;
                    status += `   文件大小: ${formatFileSize(task.fileSize || 0)}\n`;
                    status += `   上传用户: ${task.uploadUser || '未知'}\n`;
                    status += `   供应商: ${task.supplier || '未知'}\n\n`;
                });
                
                statusDiv.innerHTML = status;
            } catch (error) {
                document.getElementById('cacheStatus').textContent = `❌ 加载缓存状态失败: ${error.message}`;
            }
        }
        
        // 分析任务状态
        function analyzeTasks() {
            try {
                const cachedTasks = loadCachedTasks();
                const analysisDiv = document.getElementById('taskAnalysis');
                
                if (cachedTasks.length === 0) {
                    analysisDiv.textContent = '✅ 没有任务需要分析';
                    return;
                }
                
                const statusCounts = {};
                const expiredTasks = [];
                const now = new Date().getTime();
                
                cachedTasks.forEach(task => {
                    // 统计状态
                    statusCounts[task.status] = (statusCounts[task.status] || 0) + 1;
                    
                    // 检查是否过期
                    const taskTime = new Date(task.createdAt).getTime();
                    const hoursDiff = (now - taskTime) / (1000 * 60 * 60);
                    if (hoursDiff >= 1) {
                        expiredTasks.push(task);
                    }
                });
                
                let analysis = `📊 任务状态分析:\n\n`;
                analysis += `总任务数: ${cachedTasks.length}\n`;
                analysis += `过期任务数: ${expiredTasks.length}\n\n`;
                
                analysis += `状态分布:\n`;
                Object.entries(statusCounts).forEach(([status, count]) => {
                    analysis += `  ${status}: ${count} 个\n`;
                });
                
                if (expiredTasks.length > 0) {
                    analysis += `\n过期任务:\n`;
                    expiredTasks.forEach(task => {
                        const taskTime = new Date(task.createdAt).getTime();
                        const hoursDiff = (now - taskTime) / (1000 * 60 * 60);
                        analysis += `  - ${task.taskId} (${hoursDiff.toFixed(1)}小时前)\n`;
                    });
                }
                
                analysisDiv.textContent = analysis;
            } catch (error) {
                document.getElementById('taskAnalysis').textContent = `❌ 分析失败: ${error.message}`;
            }
        }
        
        // 检查处理中任务
        function checkProcessingTasks() {
            try {
                const cachedTasks = loadCachedTasks();
                const processingTasks = cachedTasks.filter(task => 
                    task.status === 'PROCESSING' || 
                    task.status === 'SYSTEM_PROCESSING' ||
                    task.status === 'PENDING'
                );
                
                const analysisDiv = document.getElementById('taskAnalysis');
                
                if (processingTasks.length === 0) {
                    analysisDiv.textContent = '✅ 没有处理中的任务，可以正常上传新文件';
                    return;
                }
                
                let analysis = `⚠️ 发现 ${processingTasks.length} 个处理中的任务:\n\n`;
                
                processingTasks.forEach((task, index) => {
                    analysis += `${index + 1}. ${task.taskId} (${task.status})\n`;
                    analysis += `   文件名: ${task.fileName}\n`;
                    analysis += `   创建时间: ${task.createdAt}\n`;
                    analysis += `   是否缓存: ${task.isCached ? '是' : '否'}\n\n`;
                });
                
                analysis += `这些任务会阻止新文件上传。\n`;
                analysis += `建议清理这些任务或等待它们完成。`;
                
                analysisDiv.textContent = analysis;
            } catch (error) {
                document.getElementById('taskAnalysis').textContent = `❌ 检查失败: ${error.message}`;
            }
        }
        
        // 自动修复缓存问题
        function fixCacheIssues() {
            try {
                const resultsDiv = document.getElementById('fixResults');
                let results = '🔧 开始自动修复...\n\n';
                
                // 1. 清理过期任务
                const cachedTasks = loadCachedTasks();
                const now = new Date().getTime();
                const validTasks = cachedTasks.filter(task => {
                    const taskTime = new Date(task.createdAt).getTime();
                    const hoursDiff = (now - taskTime) / (1000 * 60 * 60);
                    return hoursDiff < 1;
                });
                
                if (validTasks.length !== cachedTasks.length) {
                    localStorage.setItem(CACHED_TASKS_KEY, JSON.stringify(validTasks));
                    results += `✅ 清理了 ${cachedTasks.length - validTasks.length} 个过期任务\n`;
                } else {
                    results += `✅ 没有过期任务需要清理\n`;
                }
                
                // 2. 检查处理中任务
                const processingTasks = validTasks.filter(task => 
                    task.status === 'PROCESSING' || 
                    task.status === 'SYSTEM_PROCESSING' ||
                    task.status === 'PENDING'
                );
                
                if (processingTasks.length > 0) {
                    results += `⚠️ 发现 ${processingTasks.length} 个处理中任务，建议手动清理\n`;
                    results += `处理中任务ID: ${processingTasks.map(t => t.taskId).join(', ')}\n`;
                } else {
                    results += `✅ 没有处理中任务\n`;
                }
                
                // 3. 检查任务数量
                if (validTasks.length > 10) {
                    const limitedTasks = validTasks.slice(0, 10);
                    localStorage.setItem(CACHED_TASKS_KEY, JSON.stringify(limitedTasks));
                    results += `✅ 限制缓存任务数量为10个\n`;
                } else {
                    results += `✅ 缓存任务数量正常 (${validTasks.length}个)\n`;
                }
                
                results += `\n🎉 修复完成！`;
                resultsDiv.textContent = results;
                
                // 刷新状态显示
                setTimeout(loadCacheStatus, 500);
            } catch (error) {
                document.getElementById('fixResults').textContent = `❌ 修复失败: ${error.message}`;
            }
        }
        
        // 清理过期任务
        function clearExpiredTasks() {
            try {
                const cachedTasks = loadCachedTasks();
                const now = new Date().getTime();
                const validTasks = cachedTasks.filter(task => {
                    const taskTime = new Date(task.createdAt).getTime();
                    const hoursDiff = (now - taskTime) / (1000 * 60 * 60);
                    return hoursDiff < 1;
                });
                
                if (validTasks.length !== cachedTasks.length) {
                    localStorage.setItem(CACHED_TASKS_KEY, JSON.stringify(validTasks));
                    document.getElementById('fixResults').textContent = `✅ 已清理 ${cachedTasks.length - validTasks.length} 个过期任务`;
                } else {
                    document.getElementById('fixResults').textContent = `✅ 没有过期任务需要清理`;
                }
                
                setTimeout(loadCacheStatus, 500);
            } catch (error) {
                document.getElementById('fixResults').textContent = `❌ 清理失败: ${error.message}`;
            }
        }
        
        // 清理所有缓存任务
        function clearAllTasks() {
            if (confirm('确定要清理所有缓存任务吗？这将删除所有虚拟任务。')) {
                try {
                    localStorage.removeItem(CACHED_TASKS_KEY);
                    document.getElementById('fixResults').textContent = `✅ 已清理所有缓存任务`;
                    setTimeout(loadCacheStatus, 500);
                } catch (error) {
                    document.getElementById('fixResults').textContent = `❌ 清理失败: ${error.message}`;
                }
            }
        }
        
        // 模拟任务完成
        function simulateTaskCompletion() {
            try {
                const cachedTasks = loadCachedTasks();
                const processingTasks = cachedTasks.filter(task => 
                    task.status === 'PROCESSING' || 
                    task.status === 'SYSTEM_PROCESSING' ||
                    task.status === 'PENDING'
                );
                
                if (processingTasks.length === 0) {
                    document.getElementById('fixResults').textContent = `✅ 没有处理中任务需要模拟完成`;
                    return;
                }
                
                // 将处理中任务标记为完成
                const updatedTasks = cachedTasks.map(task => {
                    if (task.status === 'PROCESSING' || 
                        task.status === 'SYSTEM_PROCESSING' ||
                        task.status === 'PENDING') {
                        return { ...task, status: 'COMPLETED' };
                    }
                    return task;
                });
                
                localStorage.setItem(CACHED_TASKS_KEY, JSON.stringify(updatedTasks));
                document.getElementById('fixResults').textContent = `✅ 已模拟 ${processingTasks.length} 个任务完成`;
                
                setTimeout(loadCacheStatus, 500);
            } catch (error) {
                document.getElementById('fixResults').textContent = `❌ 模拟失败: ${error.message}`;
            }
        }
        
        // 测试上传阻止
        function testUploadBlock() {
            try {
                const cachedTasks = loadCachedTasks();
                const processingTasks = cachedTasks.filter(task => 
                    task.status === 'PROCESSING' || 
                    task.status === 'SYSTEM_PROCESSING' ||
                    task.status === 'PENDING'
                );
                
                const resultsDiv = document.getElementById('fixResults');
                
                if (processingTasks.length > 0) {
                    resultsDiv.textContent = `⚠️ 上传被阻止！发现 ${processingTasks.length} 个处理中任务:\n${processingTasks.map(t => `- ${t.taskId} (${t.status})`).join('\n')}`;
                } else {
                    resultsDiv.textContent = `✅ 可以正常上传新文件`;
                }
            } catch (error) {
                document.getElementById('fixResults').textContent = `❌ 测试失败: ${error.message}`;
            }
        }
        
        // 显示调试信息
        function showDebugInfo() {
            try {
                const debugDiv = document.getElementById('debugInfo');
                const cachedTasks = loadCachedTasks();
                
                let debug = `🔍 调试信息:\n\n`;
                debug += `LocalStorage 键名: ${CACHED_TASKS_KEY}\n`;
                debug += `缓存任务数量: ${cachedTasks.length}\n`;
                debug += `当前时间: ${new Date().toISOString()}\n\n`;
                
                debug += `原始 LocalStorage 数据:\n`;
                const rawData = localStorage.getItem(CACHED_TASKS_KEY);
                debug += rawData || 'null';
                
                debugDiv.textContent = debug;
            } catch (error) {
                document.getElementById('debugInfo').textContent = `❌ 获取调试信息失败: ${error.message}`;
            }
        }
        
        // 导出调试数据
        function exportDebugData() {
            try {
                const cachedTasks = loadCachedTasks();
                const debugData = {
                    timestamp: new Date().toISOString(),
                    cachedTasks: cachedTasks,
                    localStorage: {
                        key: CACHED_TASKS_KEY,
                        value: localStorage.getItem(CACHED_TASKS_KEY)
                    }
                };
                
                const blob = new Blob([JSON.stringify(debugData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai-excel-debug-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                document.getElementById('debugInfo').textContent = `✅ 调试数据已导出`;
            } catch (error) {
                document.getElementById('debugInfo').textContent = `❌ 导出失败: ${error.message}`;
            }
        }
        
        // 工具函数
        function loadCachedTasks() {
            try {
                const raw = localStorage.getItem(CACHED_TASKS_KEY);
                if (!raw) return [];
                const arr = JSON.parse(raw);
                return Array.isArray(arr) ? arr : [];
            } catch {
                return [];
            }
        }
        
        function getStatusClass(status) {
            switch (status) {
                case 'PROCESSING': return 'processing';
                case 'SYSTEM_PROCESSING': return 'system-processing';
                case 'COMPLETED': return 'completed';
                case 'FAILED': return 'failed';
                case 'PENDING': return 'pending';
                default: return 'processing';
            }
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // 页面加载时自动刷新状态
        window.onload = function() {
            loadCacheStatus();
        };
    </script>
</body>
</html>
